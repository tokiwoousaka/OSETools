*About Fulyn
-(by [[lambdalice]], 2013.07.16)

**Fulynとは？

Fulynとは、ズバリOSECPU用の高級言語、そして関数型言語だ。

諸事情によりコンパイラはまだできていないけれど、言語仕様はすでに確定している。

Fulynを使うことにより、効率的なコーディングが可能になる（かもしれない）。

**まずは書いてみよう

プログラムの基本はHello, World!だ。

しかし、Fulynのファーストリリースでは配列の仕様が確定していないので、まだ文字列を表すことはできない。

とりあえず、数字でも通じる「084（ｵﾊﾖｰ）」を表示してみよう。

    main
      print(084)
    end

まさに単純明快！Fulynはmain関数から実行される、これが重要。

Fulynは関数型言語なので、すべてが関数だ。そして、Fulynはすべてが宣言式と代入式で構成される。

print(084) は何にも代入していないように見えるが、それは後に説明する。

Fulynは高級言語だから、変数の定義もできる。

    main
      x :: int
      x = 0
      print(x)
    end

これで、int型の変数xが宣言され、xに0が代入され、0と表示された。もちろん、レジスタの定義なんてめんどくさいことは必要ない。

しかも、ものぐさなあなたのために、関数内で変数を宣言するときは、型推論機能により宣言を省略することができる。つまり、このように書ける。

    main
      x = 0
      print(x)
    end

型が「0」というリテラルから自動で推論され、「x :: int」を書いたことにしてくれるのだ。

ただし、Fulynではグローバルな変数の初期化ができない。そのため、グローバルでは、

    x :: int

としか書くことができない。代入は関数内からでしか不可能なのだ。

そして、Fulynは条件分岐が可能だ。条件分岐も式で、結果を返す。

条件分岐はこう書く。

    main
      x = 0
      y = 1
      ? x > y
      | true -> print(0)
      | false -> print(1)
    end

そう、1が表示される。

また、switch-caseのように使うことも可能だ。

    main
      x = rand()
      y = ? x % 3
          | 0 => 0xA
          | 1 => 0xB
          | () => 0xO
    end

これは、マッチする値 -> 返す式と書く。

Otherwiseは()と表す。これはfalseと同じ意味でもあり、()と書く代わりにfalseと書くことも、その逆もできる。

最後に、Fulynは四則演算も可能だ。

    main
      print((1 + 2) * 3 - 4)
    end

もちろん、5が表示される。これは内部的には関数呼び出しに変換される。

**関数を書いてみよう

関数型言語なんだから関数が書けないとまずい。さっそく書いてみよう。

でもその前に、「関数型」の表し方について解説しておこう。

Fulynは関数型言語なので、関数自体をファーストクラスに扱うことができる。

要するに、関数と関数をとって関数を返す関数もつくれるわけだ（頭がこんがらがるかもしれないけど、ついてきてほしい）。

「関数型」は、このように記述する。

    func :: [int -> int => int]

これは、Cで書くと

    int func(int,int);

と同じ意味になり、型宣言だが、働き上はプロトタイプ宣言と同じだ。

Haskellをやっている人ならわかりやすいだろう。引数の型を->でつなぎ、最後に返す型を=>でつないで書く。

関数型だけは、グローバルであっても初期化が許されている。その代り、immutable（不変）となり、再代入ができない。（定義した関数を書き換えられたらとんでもないからね）

初期化をしなかった場合は、再代入が自由なただの変数となる。

では、関数を書いてみよう。Fulynでは関数の記述に二通りのシンタックスを用意している。

ひとつはλ（ラムダ）記法。これは簡単だ。

    func :: [int -> int => int]
    func = x -> y => x + y

もちろん、受け取った二つの値を足して返す関数だ。数式に近いのでわかりやすいだろう。

ラムダは、引数を->でつないで、=>の後に返す式を書く。ちょうど型の記述と同じ形になっている。

もうひとつは、Statement（ステートメント）記法。これが難しい。

(つづく)

**こめんと

#comment

